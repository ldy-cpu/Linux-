1.gcc:
	gcc  main.c直接生成同名可执行文件；
	
	-o 只是指定名字，并不是指定编译或是编译链接，如果只编译，则gcc -o main.o -c main.c（指定生成main.o，，-c才是决定不链接，只编译）
	
	gcc  -o main  main.c  生成指定名字文件；
	
	gcc  -o main  main.c   server.c  client.c  一起编译  ；
	
	gcc  -c main.c  server.c #生成main.o,server.o   将编译和链接分开，每次只完成一项任务。这样可以提高效率，因为当源文件发生变化时，只需要重新编译变化的部分，
							而不需要重新链接所有的目标文件；
		然后gcc -o main   main.o  server.o  #链接成main
		
	-o和目标文件的位置无所谓，只要目标文件紧跟在-o后就行。
		
		
		
		
2.makefile:
	引号之前的是目标，之后的是src
	
	all:	命令行只执行make时，默认执行哪些目标。
	
	$^ 代表目标，$@代表src
	
	
	
3.头文件：
	#ifndef   #endif  是用来防止循环引用的
	
	预编译把#都去掉，换为包含的头文件中的声明，以及宏替换；然后编译和汇编生成.o；最后链接根据之前预编译拥有的声明，定位至其他.o文件或.a(静态库文件)，并链接，
	生成最终的可执行文件.
	
4.gdb:
	首先需要把待调试的文件用 gcc -g 来编译。
		调试哪个文件，就把哪个文件用-g来编译一遍.
	
	list:	查看某行附近的代码
	
	run:	运行文件，直到breakpoints
	
	continue：	继续运行
	
	set:	设置变量的值
	
	next:	单步调试（逐过程，函数直接执行）
	
	step:	单步调试（逐语句，跳入自定义函数内部执行）
	
	backtrace：	查看函数的调用的栈帧和层级关系
	
	info：	查看函数内部局部变量的数值
	
	break server.c:123:	在server.c的123行设置断点
	
	run argv[1] argv[2]：	调试时命令行传参
	
	
	
	
        
