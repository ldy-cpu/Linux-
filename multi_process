*内部命令与外部命令：
	内部命令：	集成在shell中，就在内存内部，调用时直接读取内存。
	
	外部命令：	存在磁盘中，读取时先读到内存再执行。
	
top命令行:	可以看资源占用情况

1.进程标识符pid:
	pid_t类型的，有一个上限，最多几个进程
	
	命令行查看进程状态：
		ps axf 查看进程树
		ps axm
		ps ax -L
		ps -ef

	进程号不是像文件描述符找最小，而是顺次向下，然后在循环。
	
	getpid():获得当前线程pid。
	getppid():获得父线程pid。

2.进程的产生:
	fork():		复制一份进程，连执行到的位置都一样（刚开始都是执行到fork(),且已打开的流中的内容都一样,***所以fork前要fflush）,
		注意理解关键字 duplicating 意味着拷贝 克隆 一模一样 .
	
		        fork 后父子进程的区别 ： fork 的返回值不一样; pid不同 ;ppid也不同; 未决信号与文件锁不继承；资源利用量清0。
		        
		        **(?)init进程是分水岭，init产生之前是内核程序在跑，之后内核就变成一个库 。是所有进程的祖先进程 pid == 1 
		        
		        	调度器的调度策略来决定哪个进程先运行,并不一定是父进程先运行。
		        	
        			由终端打开的进程，结束后，终端就会打印 ldy@ldy-ubuntu-1:~/c$,终端打开的进程的子进程已经和终端无关。
        			
			

	vfork()(现在用不到了):	让子进程和父进程共享同一块物理内存(指针不同，但指向的物理内存相同)。
		只能用_exit(2)和exec(3)函数族退出，避免把父进程的内存释放掉。
	
	现在的fork():
	
		写时拷贝：只读时父进程和子进程可以共享同一块物理内存，但如果有人（父子都是）要写入，则在写之前copy一份放到另外的内存，然后自己操作自己复制的这份。
			（）
	
	
	**进程分配:
		1.分块
			任务分成几大块，一块给一个进程。
			
		2.交叉分配
			任务轮流分给几个进程。
		
		
		**3.池（线程池，进程池）:
			暂放，进程冲突的时候搞。
			
		
		
		
3.进程的消亡和释放资源：

	父进程要负责释放子进程资源。
	
	如果父进程先exit，则还在执行的子进程由init接管；   如果子进程exit，但父进程还在运行且没有释放资源，则子进程由睡眠态转为僵尸态（几乎不占内存，但占用进程号）。
	（其实所谓释放资源只是释放了进程号，内存在子进程exit时就没了；这里的释放资源只能释放已exit的子进程）
	
	int wait(int *status):	       是waitpid(-1,&status,0)的封装。输入子进程状态，输出终止的进程号（收尸）。阻塞态。
	
	waitpid(int pid, int *status, int option):	option 是位图，选项有阻塞态，也有非阻塞态。（用的时候要查手册）
	
	waitid():
	
	wait3():
	
	wait4(): 

4.exec函数族：	用新的进程映象替换本来的(这样原来的程序后面就不执行了)。	子进程是和父进程完全一样的，
		除非用exec（一般的进程作为bash的子进程，是用了exec才有独特的功能）
		
		which date命令行可以找到date命令行的可执行文件的位置。
		
	execl():
		
	execlp():
	
	execle():
	
	execv():
	
	execvp():

	

5.用户权限及组权限：
	
	uid有3个：r(real)   e(effective有效的)   s(save有的没有)
		当某个用户登陆后，r始终是此用户，而当调用某个有u+s权限的文件时，e就变成了此文件的用户(shell -> <fork> -> <exec> -> 可执行文件)，e在exec时变成了
	可执行文件的用户。
	
	gid和g+s类似
	
	passwd命令行是u+s，所以运行时fork并exec的这个进程的euid为0(root),此时可以修改shadow文件中自己的密码。
	
	***	牢记uid始终是和线程绑定的，当euid为root时（即chown root ***，chmod u+s ***）,可以有root权限，可以setuid为其他用户号；但set之后这个线程的euid就
	变成了set的号，已经没有root权限。所以要想让这个程序sudo有root，没sudo没root，则刚开始需要有root权限，然后如果有sudo，则判断密码是否正确（这个需要shadow访问权，即root权限，所以此步骤之前必须是root）；如没sudo，则这个fork之后的程序设为ruid（不影响fork前的父进程root的身份）。见mysh。
	
	
	
	
		

6.观摩课：解释器文件

	文件后缀无所谓，开头是   #!/usr/bin/bash
	相当于用bash去解释这个文件中的东西，而#在bash中是注释的意思，所以第一句没有运行。
	
	#!/usr/bin/cat    
	相当于cat解释这个文件，而#在cat中不是注释，所以相当于编辑这整个文件。

7.system():	在c中调用命令行
	相当于fork、exec、wait的简单封装

	
	
	

8.进程会计
	
	acct():方言
		当进程消亡的时候。。。

9.进程时间

	times():	获取进程时间（获取的结构体中即有本进程时间，也有子进程时间）。

10.守护进程：	服务这类进程脱离终端的，不受终端信号影响
	
	会话session：	sid.*********一次控制台登陆就是一个会话*************************
	
		一个shell就是一个会话
		
		 前台进程组：	最多有一个（比如一个shell，如果执行一个下载命令，我们无法进行操作，因为shell创建的下载子进程正在运行，shell正在wait），可以用标准
	 		输入输出。
		 
		 后台进程组：	可以有很多个，但无法使用标准输入输出，因为不知道是给哪个线程的。
		 
		 可以把前台进程组放入后台进程组。
		 
		 setsid():	 调用者不能有子进程，调用后创建一个session，并变成进程组的leader，并且脱离控制终端。
		 	调用后此进程不需要被收尸，其父进程可退出；此时此进程的ppid（父进程id）为1（init）。
		 	
		 	*******************为啥不加setsid也没影响
	
		getpgrp();getpgid();setpgid();
	
	单实例守护进程：锁文件  /var/run/name.pid    （记录这个进程的pid）
			用于控制某个进程只有一份在跑，无法启动多个
			
	启动脚本文件：	/etc/rc*...(我没有)	可以把需要开机启动的守护进程的启动命令写在里面，开机自动启动
			

11.系统日志

	syslogd服务:
		openlog():	打开日志文件
		
		syslog():	提交日志文件
		
		closelog():	关闭此文件流


