									流媒体项目



__attribute__(packed)？ 
extern??


多播需要setsockopt。



server和client 端口号为啥他的一样，我现在写的不一样。


client:

	接收的时候一般用while(1)，因为不确定一开始接收的是一个完整的包。
	其实所有内容都接收了，只是接收后判断是否是自己想要的chnid.

	write()要坚持写够
	
	
	
server:
	daemon   setsid()之前，一般要fork(),父进程直接退出即可.
	fd = /dev/null, du2p(fd,0),du2p(fd,1),du2p(fd,2)	if(fd>2) close(fd)	?为什么这么做，为什么不这么做就会内存泄漏
	
	守护进程chdir
	
	/*系统日至*/
	
	信号处理函数用的sigaction
	
	
	glob()解析目录
	
	server.c传入的list二级指针，如何保证在添加频道信息时不会内存泄漏？我目前用的指针数组。
	
	*****udp可以多个线程对同一个socket操作，因为内核缓存是自带互斥的，而且udp一次发送一个包，不会有断流，然后另一个线程发送的混乱现象。
	*****而tcp则不可以，虽然互斥，但是不一定一次写完，写完一次之后，可能另一个线程继续写，这样客户端收到的就是混乱的数据。
	
	pthread_create()的参数用传值。
	
	多播组的地址：224.2.2.2：？？，端口是server端的端口吗？好像是接收的端口，相当于规定好想接收的都必须使用此端口。
	
	listentry->len 本来是方便往list中的数组添加，我没用到，用了strlen,详见thr_list.c
	
	
	
	*目前两端都可以运行，但client端接收不到包，不知道地址哪里搞错了。。。。。。端口号要htons而不是htonl
	
	
	地址加减，一般要转化成char*，加减完之后再转回原来的。
	
	发送信息不能太长。
	
	如何精准流控？
			这里我用了读写锁,但其实并不是真正读和写，而都是写，只是获取token的线程互相不冲突，可以同时写，而生产token的线程则需要加写锁。
			例子用了多个mutex，每个token对应一个mutex，这样生产者不用等所有消费者都解锁才能去+token。（不过这样效率感觉也不高）
			
	播放时还是会乱，是否与udp包无先后顺序有关？。。。。。。无关，只是流控没有设置好。
	

	
	
	
	
	
	
	
	
	开环流控，闭环流控
	
	
	
	
	
