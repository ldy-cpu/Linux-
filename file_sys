1 Byte(字节) = 8 bit(位)   1 MB指的是字节。
char也是用数字保存的(ASCII码)，不过只占1字节，int占4字节。
ASCII码可以和int相互转换（int转ASCII时不能大于1字节表达的数）.
char[]在栈上.

文件系统********************************************************************************

         声明的指针，都必须指向一个地址，int *a;用的时候也得a = (int*)malloc(sizeof(int))才能用；不管在main还是其他函数，声明指针的，都会在堆区，要手动free();
所以如果一个函数要返回地址的话，一定要struct* b = (struct*)malloc(sizeof(struct));再return b；如果不需要返回地址，则最好struct b;这样函数结束会自动
释放栈内存。（数组在栈中）

inode是索引节点，硬盘里的一个分区，里面存着硬盘数据区的文件信息。






目录和文件：
	获取文件属性：	
		int stat(const char *path,struct stat *buf);	
				其中的size属性只是一个属性，并不是具体占磁盘的大小，如果拷贝一个空洞文件，则会记录它空洞的大小，然后存入目标，但目标并没有实际
			申请这么过的空间(22.04不是这样)。
		int fstat(int fd,struct stat *buf);
		int lstat(const char *path,struct stat*buf);(一般l打头的是链接的意思)	
		
		文件类型：	d(direct) 目录文件      c (character) 字符文件       b(block)块文件    -(regular)常规文件      l(link)符号链接文件  
			        s(socket)网络套接字文件       p(pipe)管道文件
		
	文件访问权限：	与上述文件类型一起查询 ，如 -rwxr--r--   第一个位代表文件类型，往后的三位代表用户文件访问权限，再往后三位代表用户组访问权限，
			再往后三位代表其他用户访问权限。
	
	umask：		一般为0002（四位八进制，表示32bit），第一八进制位表示特殊权限，第二表示用户的rwx权限，以此类推。
		可通过umask命令行来改变umask码，是c中的umask函数封装成的。umask转为二进制为1的位,则用原权限减去，所以umask是表示默认没有的权限，相当于"补码"。
		(创建文件时可执行只能为0,文件夹可为1,所以umask 0000也只能创建出chmod为0666的文件，chmod为0755的文件夹)
	
	文件权限的管理：	chmod命令行，chmod 0666 test  ,用来改变test文件权限，chmod转为二进制的1表示激活权限，0表示关闭权限，和上述相反.
				chmod为c的chmod函数封装.(fchmod)
	
	粘住位：	t位
	
	文件系统：FAT，UFS：	
		FAT：
			静态单链表，struct{int next[n],char data[n][size]},通过当前next数组中的内容，找到下一个next位置，从而在data中找到对应。
			n值有限，所以FAT格式有最大文件上限。
		
		UFS:
			磁盘分为inode区和数据块区，stat取出的信息都在inode结构体中.
			查找文件是在inode分区找，所以如果存多个小文件，则查找麻烦。
			每个inode结构体中有多个指针指向数据块，如果文件很大，则一级间接多个指针指向数据块，这个数据块中存的是指向信息数据块的指针。
			二级间接是指向多个一级间接。
			所以UFS非常善于管理大文件。
	
	目录文件('d')：
		每个目录都是一个目录文件，其中存着inode信息和文件名。
	
	硬链接，符号链接：
		ln命令行是c link函数的封装。
		硬链接：父目录文件下对应的inode和文件名，使用ln  src  dest命令行，则在父目录文件下增加了一行src的inode对应一个新的名字dest（类似于两个指针
			指向同一块内存）。（dest是一个regular文件类型'-'）
		符号链接：ln -s src dest命令行，相当于创建了一个dest文件（不占块，只在inode节点中存）存储了src文件名（windows中快捷方式原理），不增加原inode
			的链接数。(dest是一个链接文件类型'l')
	
	
	utime
	
	目录的创建和销毁：mkdir  rmdir
	
	更改当前工作路径：可理解为程序中的相对路径是根据工作路径决定的，所以改变工作路径，程序中的相对路径意义就改变了。
			chdir 改变进程的运行路径，比如u盘中的程序在跑，想拔掉u盘，要先切换工作路径。
			 getcwd 获取当前工作路径
	
	**分析目录：
		glob():找到符合pattern的路径名。 记得要globfree();因为glob_t可能是局部变量，但glob_t中的gl_pathv是malloc出来的，所以要在有gl_pathv的时候
		再用globfree();
		
	
	
系统数据文件和信息：
		struct passwd * getpwuid(); 	其中可用atoi函数把命令行传入的字符串参数转化为int
		
		/etc/shadow:	存放了一些加密后的密码之类，很重要。普通用户无法读写，root可以。root除了不能让无法运行的东西可执行，其他都能干。
				（hash不是加密而是混淆，它无法解密（不可逆））
				
				getspnam():	获取某个用户的shadow信息。
				crypt():	输入原串，位或salt然后用特定加密方式加密（这些信息都在shadow信息中的密码串中，直接传入即可），得到加密串。
						(我的ubuntu版本，要用头文件<crypt.h>，并且编译时要gcc chkpass.c -o chkpass -lcrypt)
				getpass():	类似于gets,但不显示输入的内容。
		
		时间戳：	time();从内核中获得某个时刻到现在的大整数time_t。
				gmtime();将time_t转化为一个格林威治时间结构体。
				localtime();.....转化为一个当地时间结构体。
				mktime();将结构体转化为time_t.
				strftime();将结构体转化为格式化的字符串.
				
				tail -f: shell命令，动态打印文件最后一行.

进程环境：
	1.main函数：
		int main(int argc,char *argv[])
		原来是有第三个参数的，环境变量，现在另成一个分支。
	2.****进程的终止：
		正常终止：(最后要刷新流，调用钩子函数等)
			main():		函数返回  return 0。  这个return是给他的父进程看的，main的父进程是shell
				命令行 echo $?显示上一个返回的值
				
			exit():		是std，所有被atexit和on_exit函数注册的函数在这时都要调用一遍
				是对_exit，_Exit的封装，执行时先在用户空间调用钩子函数、清理标准I/O（如fflush等），然后再调用_exit退出用户空间，进入内核。
			
			
			_exit或_Exit：	是sys。一旦发现程序出现内存泄漏的情况推荐使用这种（或abort），避免错误的内存被刷到内核缓存然后进一步刷到磁盘。
			
			最后一个线程从其启动例程返回:
			
			最后一个线程调用了 pthread_exit:
			
		
		异常终止：(什么都不做直接终止)
			abort():
			
			接到一个信号并终止:
			
			最后一个线程对其取消作出响应:
			
			
		int atexit(void(*func)(void)):钩子函数（类似析构函数）
			执行这条语句是把func挂在钩子上，最后exit时才调用，（符合栈的规律）。
			
			
		
	3.命令行参数的分析：
		getopt():	会自动识别'-'后面的char，而且每次调用都会自动的从上一次检索的命令后继续（猜测定义了静态区变量）
			(其实是外部变量optind，是argv的下标)。
		getopt_long():
	
	4.环境变量（environ）：	就是程序员和管理员之间的约定,🤞️每个进程空间都有环境变量🤞️。用全局变量extern char** environ即可查看。
		export:		命令行查看环境变量
		
		PATH：		保存的是全部bin（二进制文件）的路径,都是外部命令，保存在磁盘上的。
		
		内部命令：	作业调度，路径，管道等。（也可以说是不在bin文件中的命令）
		
		char *getenv(const char* name):		通过一个KEY得到一个VALUE，如："PATH" = "/usr/bin......"，PATH 为KEY，右边为VALUE。
		
		setenv():	改变或新建一个环境变量。
		
		putenv():	
		
	5.c程序的存储空间布局:
		
		有一部分时留给内核的。
	
		ps axf 命令行查看当前进程空间。
		
		pmap *** 命令行，***代表进程号PID(process id)查看进程内存空间布局。
		
	
	6.库：
		动态库：扩展名一般为.so或.dll,编译时不会编译，可执行文件不可单独运行。升级库方便，不需要重新编译。
		
		静态库:扩展名一般为.a或.lib,编译时编译进可执行文件，可单独运行。库升级如果想用，需要重新编译。
		
		手工装载库：	内核模块，其实类似于插件，可以启用则启用，不可以则先跳过，不影响其他模块使用
				
				dlopen():	手工加载一个库，比如要用到math库，可以先不在头文件生明，然后用这个打开。
				
				dlclose():
				
				dlerror():
				
				dlsym():
		
		
	
	7.函数跳转：
	
		setjmp():
			设置跳转点。
		
		longjmp():
			跳转到跳转点。可以跨函数跳转
			
		goto不可以跨函数。
	
	8.资源的获取与控制：
		ulimit命令行可以获取当前用户的限制。
		
		getrlimit():	从资源获取limit。
		
		setrlimit():	将现在的limit结构体中的内容设置到资源。
		
		rlimit分为cur (soft limit)和max(hard limit),普通用户可以随意操控cur，只能降低max不能升高；root可以升高也可以降低max。
		
		
	


