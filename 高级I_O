									高级I_O
非阻塞IO：	尝试写入或读取，若没成功也返回，并不等待。
阻塞IO：	死等。

****补充：	有限状态机FSM编程：	暂时理解为把各种状态装载在一个结构体(cpp中的类)，然后定义驱动函数，根据结构体中的各种状态变量处于什么状态，来作不同的事情。
				是一种编程思想。
					配合画图来写代码。

1.非阻塞IO
	最典型用在单个线程循环处理数据，上一个IO阻塞，则下一个可用的IO也一直得不到处理，所以最好用非阻塞IO。
	阻塞IO双线程一个处理上一个IO。一个处理下一个也可行。
	
	简单流程：	自然流程是结构化的。
	复杂流程：	不是结构化的。有限状态机
	
2.IO多路转接
	这里代码和视频的效果不一样。。。。。
	暂时不管了
	select():
		等待感兴趣的文件描述符集发生事件，然后作处理。
		使用和signal中类似的位图。
		解决了忙等。

	poll():
		和select功能差不多，但使用链表记录文件描述符。

	epoll():

3.其他读写函数
	readv():
	writev():
	
	多个碎片的小地址，一起读写


4.存储映射IO
	是一种进程间通信IPC
	··CPU同时只能运行一个进程（并发但不并行），每个进程的虚拟地址和物理地址的翻译是不一样的（比如两个进程虚拟地址一样的地方对应的物理地址不一样），
	系统每次在切换进程时，地址对应表也切换了。
	
	比如在进程中把文件的物理内存（打开的流）映射到本进程中的一块char*的内存（虚拟内存）中。
	mmap()：
		将某个fd从某个off_set开始映射一定的长度至此进程的
		如果没有选择fd，则是系统给你一块物理内存，给你映射到虚拟内存。
	munmap():
		释放掉映射
		
		
	个人认为和write，read差别在可以不要已有的文件描述符，而新开辟一段物理地址（可代替malloc,free）。(没成功).
		
	

5.文件锁
	读写锁
	
	fblock():	
		只能加建议性锁。

		只能对整个文件加锁，而不能对文件的某一区域加锁。

		使用exec后，文件锁的状态不变。

		flock锁是可以递归，即通过dup或者fork产生的两个fd，都可以加锁而不会产生死锁。因为其创建的锁是和文件打开表项（struct file）相关联的，而不是fd。
		这就意味着复制文件fd（通过fork或者dup）后，这两个fd都可以操作这把锁（例如通过一个fd加锁，通过另一个fd可以释放锁），也就是说子进程继承父进程的锁。
		但是加锁过程中，关闭其中一个fd，锁是不会被释放的（因为struct file并没有释放），只有关闭所有复制出的fd，锁才会被释放。

		使用open两次打开同一个文件，得到的两个fd是独立的（因为底层对应两个struct file对象），通过其中一个fd加锁，通过另一个fd无法解锁，并且在前一个解锁
		前也无法加有冲突的锁。

		flock在NFS文件系统上使用时，服务端NFSD将文件锁的类型由FLOCK改为POSIX。？

		不会进行死锁检查。
		
		
	lockf():
		只支持排他锁，不支持共享锁。
		是在inode层面上锁，不是struct file。
		
	fctnl
		由fork产生的子进程不继承父进程所设置的锁，与flock不同。
		
		在执行exec后，新程序可以继承原程序的锁，这点和flock是相同的。（如果对fd设置了close-on-exec，则exec前会关闭fd，相应文件的锁也会被释放）。
		

