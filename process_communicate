									进程间通信
包括同一台主机和不同主机的进程


***	打开的文件,描述符数组[fd]->内核中的struct.缓存指针->内核缓存；所以两个进程对同一个文件操作，是对内核中的缓存进行操作，还不是物理地址。

	进程通信千万不能传递指针，因为不同进程虚拟地址都不一样。
									

1.存储映射（高级IO中有详情）：(同一台)
	存储映射是直接操作物理地址，而管道，则是操作内核缓存中的打开文件，然后由内核在自己的虚拟地址中找到对应的物理地址。

2.管道：(同一台)	
	**pthread_cond，如果在wait调用前，其他线程就发送了signal或broadcast怎么办？？
	
	
	可以当作是一种队列，有进程内部的（自己创造的，详见mypipe.c），也有进程间的通信。
	进程间的是内核创建的，单工，自同步机制
	
	匿名管道：
		只能是有亲缘关系进程，pipefd中结构体里的指针才能指向同一块物理内存。
		int pipe(int pipefd[]):0端读，1端写 	（个人感觉和普通fd，一个写，一个读是一样的；但之前试了没成功）（原理上是差不多的，只是一个fd，写后想要
		读，偏移量需要重置，所以发明了pipefd）。
		
		
		**实例中，父进程用alarm()发信号，子进程收不到；用kill发信号可以；子进程用sigwait()收不到信号，用pause()可以。为什么？

	命名管道：
		可以没有亲缘关系。
		mkfifo:		命令行，创建一个管道文件。	可在命令行往管道中写，然后另一个bash从管道中读。必须凑齐读写双方才行。
		mkfifo():	同样创建一个管道文件。
	
3.XSI -> SYsV:(同一台)
		可以没有亲缘关系。
		
		****操作系统来保证这三个机制的原子性。
		
		这三种机制都包含key
		key是为了确定通信双方拿到同一个通信机制
		
		key_t ftok(const char *pathname, int proj_id);
		
		xxxop(使用) xxxctl(控制，销毁)
		1、Message Queues(消息队列)
			int msgget(key_t key, int msgflg);	创建消息队列,返回一个实例id。
			
			int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);//发送
			
       			ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);//接收
       				结构体中规定必须有一个long型的大于0的数字，而msgsz指的是有效的内容大小，而不是结构体实际传来的大小，所以一般用结构体大小-long
       				大小。因为不知道接收到的到底是哪种结构体，所以定义long类型的来分辨到底是哪种结构体。可以发送和接收共用体，里面有所有类型可能的
       				结构体，还有一个long型，用来判断用这个共用体 . 什么结构体。

			
			消息队列是双工的,双方都能msgget和msgrcv。
			
			
			和管道的区别：	是以消息为单位，即消息结构体，数据比管道的高级。
					消息队列是全双工，管道是半双工。
					*消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大。
			

		2、Semaphore Arrays(信号量)
			信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
			
			int semget(key_t key, int nsems, int semflg);	创建信号量。
			
			semctl():	对信号量进行初始化。
			
			int semop(int semid, struct sembuf *sops, size_t nsops);	对信号量进行操作，struct sembuf是在本函数中创建的结构体，里面封装了本次
									操作是对哪个信号量下标，进行+多少-多少。
									
			可以代替文件锁，不用锁文件了，直接创建一个总量为最大读的信号量，一个进程对文件读，信号量-1,一个读完+1.一个写，则把信号量全占了。
			

		3、Shared Memory Segments(共享内存)
			int shmget(key_t key, size_t size, int shmflg);		创建共享内存。
			
			shmop:
			
				void* shmat(int shmid, const void *shmaddr, int shmflg);	将申请的共享内存的物理内存映射到当前进程的虚拟地址空间上,
										shmaddr一般传NULL，由系统自动选择映射的虚拟地址空间.
				
				int shmdt(const void *shmaddr);		断开当前进程的shmaddr指向的共享内存映射
			
			shmctl();	
			
			通常配合信号量使用（简单的功能也可以用信号实现，kill(),详见myppipe）
		
		
		


4.网络套接字socket：(不同主机)
	跨主机传输要注意的问题：
		1.字节序：
			大端字节序(低地址高字节)
			小端字节序(低地址低字节)
			主机字节序(host)
			网络字节序(network)
			
			网络数据流应采用大端字节序(低地址高字节)。如果本地主机是小端字节序的，则需要考虑网络字节序和主机字节序的转换问题。
			考虑程序可移植性，一般都要转换一下
			
			解决：
			
				uint32_t htonl(uint32_t hostlong); // 本地字节序转网络字节序(IP)
				uint16_t htons(uint16_t hostshort); // 本地字节序转网络字节序(Port)
				uint32_t ntohl(uint32_t netlong); // 网络字节序转本地字节序(IP)
				uint16_t ntohs(uint16_t netshort); // 网络字节序转本地字节序(Port)

		2.对齐：
			每个计算机对齐的方式不太一样，所以一个结构体所占空间大小不一定是里面所有成员大小相加，可能中间会空出几个字节，实际占位大于成员相加。
			而通讯时为了避免不同对齐产生歧义。
			解决：结构体选择不对齐。
			
		3.类型长度：
			32位和16位机器int所占空间不一样大，一个4字节，一个2字节。
			解决：用int32_t,uint32_t,int64_t,int8_t,uint8_t来代替int
			
		4.指针：
			网络传输千万不能传输指针，因为换进程了，虚拟地址全变了。
			其实同主机进程通信也不能传指针。
			
			
	socket是什么：
		实际上就是双方用什么协议，以及什么样的传输方式，封装为一个伪文件socket，然后传输过程就以这个socket中的各种协议为标准。
		
		int socket(int domain,int type,int protocol);		用domain协议族中的protocol协议对type类型的数据进行传输；返回一个文件描述符。
		
		bind();		将socket和自己的ip以及端口匹配起来。
		
		inet_pton();	将一个点分式如192.168.1.1转换为大整数。
		
		inet_ntop();	将一个大整数如转换为点分式。
		
		recvfrom();	从一个socket中获取数据
		
		sendto():	
		
		为什么有的数据用hton，ntoh，有的不用？：似乎只有整型数需要转化。
		为什么接收端的对端地址没有初始化？
		

		
		
	报式套接字：
		这里可以使用 变长数组，传输结构体不怕不够长，也不怕太长占用网络资源;	结构体最后一个元素定义为数组(长度为空，但例子里定义为1？)，结构体
		长度不算这个数组，sendto()的时候大小要写成sizeof(struct **) + sizeof(数组大小);rcver因为无法提前知道数组长度，所以还是定义为
		sizeof(struct **) + sizeof(MAX)。
	
		详见bsocket
	
		接收流程：
			1.有规定好的数据报的格式，通常不对齐。
			2.建立socket(协议族如ipv4,ipv6,具体协议如tcp/udp，数据类型如数据报/流)。
			3.创建本地地址结构体struct sockaddr_in laddr；将点分式ip地址转化为大整数，存入laddr；协议族存入laddr；端口号htons，转化为网络字节序。
			4.创建对端地址结构体raddr；接收端不重要，因为对方先发信息 ，然后就拿到了对方的地址，然后填入也行。
			5.绑定socket和本地地址laddr；因为地址laddr大小不确定，所以要转void*,再根据sizeof(laddr)来确定这个结构体真实大小。
			6.接收，大整数ip地址转化为点分式；整型数ntohs，转化为主机字节序。
			
			
			网络上的数据通过端口写入到sfd文件中，然后再由本机cpu从sfd中读取。
			
		发送流程：	
			1.有规定好的数据报的格式，通常不对齐。
			2.建立socket。
			3.创建本地地址结构体struct sockaddr_in laddr；将点分式ip地址转化为大整数，存入laddr；协议族存入laddr；端口号htons，转化为网络字节序。
			4.创建对端地址结构体raddr；发送端必须有，这样才能找到要传送的位置。
			5.绑定socket和本地地址laddr。
			6.发送。
			
			
			将要发送的数据由cpu写入sfd文件，然后通过端口把sfd的内容读取并发送。
			
			发现地址显示127.0.0.1,是回送地址，说明没有经过路由转发。
			
			
			
			
		多点通讯(只有报式有):
			getsockopt():

			setsockopt():	更改各种选项，比如是否允许广播的开关就在里面。
		
		
			广播(全网广播，子网广播)：
				全局域网：255.255.255.255（需要把广播开关打开）
				
					接收方显示192.168.17.128,说明经过路由转发。
				
				



			多播(D类地址)：
				snder创建多播组，rcver加入多播组。
				
				224.0.0.1是一个所有成员都在的组，且无法离开。所以这个地址也相当与广播。
				
				
				
				
		停等式流控：
			发包之后要等待对方校验已收到包。
			更优的做法是窗口式流控，这样不会死等；类似于并发提高效率，在等待确认时还还能继续发送新的包，除非待确认窗口已满。
			
		
	
	
	
	
	
	流式套接字：
	
		三次握手：
			1、客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连
		接。（SYN=1，seq=x，x为随机生成数值）；

			2、服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在
		客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机
		生成数值）这里的ack加1可以理解为是确认和谁建立连接；

			3、客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。
		（SYN=1，ACK=y+1，seq=x+1）。
		
		四次挥手：
			1、客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。
		（FIN=1，seq=x，x由客户端随机生成）；

			2、服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq
		序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）；

			3、服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输
		数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）；

			4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上
		加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）至此TCP断开的4次挥手过程完毕。


		cookie：
			通常代替半连接池（服务器收到的第一次握手，并回复了第二次握手），半连接池容易遭到DDOS攻击，即只发送第一次握手，不发送第三次，导致占用
		服务器资源。
			而cookie则是第二次握手把双方ip,port,proto或上一个salt，得到的哈希值，发送给c端，然后c端进行第三次握手时把刚才的cookie带上，然后s端
		验证，成功的话即建立连接。
		
		
		***一定记得端口号是htons(),而不是htonl().
		
		
		
		
		命令行nc:	nc是netcat的简写，是一个功能强大的网络工具，有着网络界的瑞士军刀美誉。nc命令在linux系统中实际命令是ncat，nc是软连接到ncat。nc
			命令的主要作用如下：

			    实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口
			    机器之间传输文件
			    端口的扫描，nc可以作为client发起TCP或UDP连接
			    机器之间网络测速
			
			    
	    	***********************
	    	详见c/lsocket
	    	
	    	*因为tcp是流式传输，所以不一定是一个完整的结构体，所以一般开头用一个整型数来标记这个结构体剩余成员大小，而读取这个整型数本身也不一定会一次性读完，
	    	所以循环recv(),而每次recv都是原来地址加上这个结构体已读的长度，直到一个完整结构体读出，然后才去读下一个。
	    	
	    	server流程：
			1.有规定好的格式，通常不对齐。
			2.建立socket(协议族如ipv4,ipv6,具体协议如tcp/udp，数据类型如数据报/流)。
			3.创建本地地址结构体struct sockaddr_in laddr；将点分式ip地址转化为大整数，存入laddr；协议族存入laddr；端口号htons，转化为网络字节序。
			4.绑定socket和本地地址laddr；因为地址laddr大小不确定，所以要转void*,再根据sizeof(laddr)来确定这个结构体真实大小。
			5.listen()开始监听。
			6.accept()与监听到的连接请求建立连接，并返回一个新的socket fd，之后的发送接收都是从这个新的fd。
			7.发送及接收，大整数ip地址转化为点分式；整型数ntohs，转化为主机字节序。
			8.断开连接。
			
			
		client流程：	
			1.有规定好的格式，通常不对齐。
			2.建立socket。
			3.创建本地地址结构体struct sockaddr_in laddr；将点分式ip地址转化为大整数，存入laddr；协议族存入laddr；端口号htons，转化为网络字节序。
			4.创建对端地址结构体raddr；发送端必须有，这样才能找到要传送的位置。
			5.绑定socket和本地地址laddr。（可有可无）
			6.connect()请求连接。
			7.发送与接收。
			8.断开连接。
			
			
		**********************************
		
		服务端并发处理：
			1.accept()天生互斥，把accept()写入子进程中，一次只有一个进程的accept()可以建立连接。
			
			2.把accept()写入父进程，然后用消息队列等进程间通信，把newsfd分发给各个子进程。

	
	
	
	
