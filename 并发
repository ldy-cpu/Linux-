								并发（信号、线程）
		
同步：	单核分时间片轮流给线程用

异步：	多核同时执行不同的线程。查询法，不停查询，不知道什么时候发生，适用于事件发生很多；通知法，发生时有东西通知，适用于事件发生不多不频繁		
		
		
封装：	

sig_atomic_t替换int，保证赋值的原子性
								
一.信号（多进程并发）
	1.信号概念
		信号的响应依赖于中断。是软件层面的中断。（？？）
		信号处理函数和主函数属于同一进程同一线程，并没有并行运算（因为是中断后扎内核返回此进程时，发现有信号，进入到处理函数，结束后，扎内核，
		再返回主函数）。
		
	2.signal(int signum，sighandler_t handler):
		handler的参数int表示受到的信号类型.
		注册处理函数后，收到信号后，是由系统分配谁去执行这个handler，和本线程无关了。（所以和本线程是异步的，要注意变量的原子性）
		一个signum对应一个 处理信号的handler，此函数可以指定新的handler函数的指针；从此接受到signum信号时，就使用指定的handler处理
		信号会打断阻塞的系统调用 ，在可能发生的系统io调用后加个循环，并判断errno是真错还是假错（假错就是信号打断了阻塞的系统调用，可重新调用）。
		
	3.信号的不可靠：
		因为处理信号的handler是内核布置的，所以第二个信号发生时，内核很有可能将第二个handler布置在第一个，第一个没执行完的就失效了。
		解决方法：1.只接收一次信号（淘汰了） 2.链式
	
	4.可重入函数:
		一个函数可以被调用多次（上一个还没结束时），所有系统调用都是可重入函数，部分库函数可重入。
	
	5.信号的响应过程：
		cpu时间片用完，或被其他方式中断后，保存现场，下次由内核态分配cpu时，用mask&pending，判断是否有信号需要响应。
		
		信号响应是有不可避免的延迟的，因为要等中断后恢复时才判断是否响应。
		
		标准信号的响应没有严格的顺序。
	
	6.常用函数
		kill();		杀死某个或某组进程。
		
		raise();	杀死某个线程，如果是单线程进程，则等于kill(getpid()).
		
		alarm();	规定秒数后发出SIGALARM信号。默认设置为结束进程。
		
		setitimer():	可循环发出alarm信号，精确到微秒，可替换alarm();
		
		pause();	使本进程休眠，直到有信号传入（不管是杀死此进程，还是调用handler）。
		
		abort();
		system();
		sleep();
		
	7.信号集：
		sigset_t set; 自定义信号集		其实就是把要改变的信号放在一个集合中，集中改变。实际改变的还是本进程的mask
		sigemptyset(sigset_t *set); 清空信号集
		sigfillset(sigset_t *set); 全部置1
		sigaddset(sigset_t *set, int signum); 将一个信号添加到集合中
		sigdelset(sigset_t *set, int signum); 将一个信号从集合中移出
		sigismenber(const sigset_t *set, int signum); 判断一个信号是否在集合中，在返回1，不在返回0

		
	8.信号屏蔽字/信号pending集的处理：
		int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);将集合作处理，新的mask放在set，旧的放在oldset的地质上，不关心的话可以写NULL
		
		         进入信号处理函数时会将本信号加入全局信号屏蔽字，退出时还原，所以在信号处理函数里面对信号屏蔽字所做的操作只在该函数有效！一旦返回到main函数或者
		其他函数，系统将会恢复全局屏蔽字，也就是保留之前的屏蔽操作。意味着在信号处理函数里调用sigprocmask是不明智的选择，因为退出信号处理函数以后屏蔽字
		恢复成之前的状态（全局信号屏蔽字）。要修改屏蔽字，就需要在其它非信号处理函数调用sigprocmask修改当前进程的信号屏蔽字/集合。

		
		sigpending();	取出pending位图。
		
		mask：32位图，一般全为1,表示此信号可以被响应
		
		pending：32位图，初始全为0,接收到信号则1
		
			cpu时间片用完，或被其他方式中断后，保存现场，下次由内核态分配cpu时，用mask&pending，判断是否有信号需要响应。
			
			如果有，则将mask置为0（为防止重入），pending置为0，直接去到注册的处理信号函数的地址，当handler执行完毕继续进入内核态，等下个cpu时间片分配至	
		程序，则恢复现场，mask置为1。
		
		handler函数不能随意setjmp(),因为最后要将mask置为1,跳出可能会跳过此过程，则以后此信号永远不会被响应。
	
	9.扩展
		*sigsuspend(sigset_t set);
			在解除阻塞和pause()之间，很有可能先处理信号；因为阻塞时，pending位变为1,等接触阻塞的同时相当于接收到了信号，这样后面的pause()就接受不到信号
			会永久暂停。
			所以用此函数，将解除阻塞和pause()做成原子操作，之后再去响应此信号的handler，并pending置为0.
			
			set需要是你想要响应的信号为unblock，即进入此函数时替换为set，出来时恢复原样。
		
		sigaction();
			功能更丰富的sighandler。
			其中sa_mask保存希望执行handler时阻塞的信号。(因为同一个handler可以处理多个信号，而当执行时，其他信号发生，容易发生重入，所以要把sa_mask
			中的信号都block).
			可以区别对待从kernal中来的信号(alarm();)和user来的(kill -ALRM 进程号)。还可以分清是哪个进程来的。不至于被另一个终端上的信号影响.
	
	10.实时信号：
		不会丢失信号。
			

	
	
二.多线程并发
	线程函数的代码段内存是共用的，但栈都是独立的

	1.线程概念：
		就是一个正在运行的函数，线程有两种标准，一种是posix线程，一种是openmp线程。

		线程标准是一套标准，而不是实现，例如posix线程标准的线程标识pthread_t，这个线程标识没有确定的类型，在不同的系统上实现形式是不同的
		（例如windows和macos上的实现标准有可能就不相同，有可能是链表或者数组），因此我们可以直接使用，但是不能用类似"%d"的标准将其打印。
		
		pthread_equal();	比较两个线程是否是一个（编译链接时要加上-pthread）
		pthread_self();		获取当前线程标识。
		
		 
	2.线程的创建：
		pthread_create();	创建一个线程，决定属性
		
		
	    线程终止：3种方式
	    	1.线程从启动例程返回,返回值就是线程的退出码;
	    	2.线程可以被同一进程中的其他线程取消；（异常终止）
	    	3.线程退出调用 pthread_exit() 函数。(如用return，则无法做线程栈的清理)（类似于exit可以触发钩子函数）
	    	
	    	pthread_join();类似于wait函数，用来收尸
	
	    栈清理 ：
		pthread_cleanup_push():		类似atexit,挂钩子函数
		
		pthread_cleanup_pop():		逆序执行钩子函数，如果参数为0,则只出栈，不调用。
		
		必须成对出现（好像是宏定义，少一个pop就相当于少半个括号）
	
	
	   线程取消：
		pthread_cancel():	取消指定线程，然后再用pthread_join()收尸；一般需要free的系统调用，成功打开后都要cleanup_push一个函数，这样被cancel的话
				也可以正常释放内存。
				
		有两种状态：允许取消和不允许。
			允许：1.异步cancel（暂时不管）；2.推迟cancel(默认),推迟至cancel点再cancel。
			cancel点：posix定义的cancel点，都是可能引发阻塞的系统调用；这样就不会 成功malloc但来不及push函数。

		pthread_setcancelstate():设置是否允许取消

		pthread_setcanceltype():设置取消方式

		pthread_testcancel():本函数什么都不做，就是一个取消点(相当于创造一个会阻塞的系统调用)。

			
		使用 pthread_detach()，线程分离后，主线程不再管负责收尸工作。
		
	线程竞争：	
		因为pthread_create()传得参数是地址，所以可能赋值成功之前，就改变了，所以影响上一个线程。这里可以传值，然后强转成void*，在线程里再强转成int或其他；
		或者定义一个结构体，然后每次都malloc结构体，把要传的参数放在结构体中，然后传入结构体的地址。
		
	3.线程同步：
		互斥量：	多个进程可能发生冲突，比如都要读取某个文件，然后修改写入，这样可能上一个还没写入，下一个就读取了，这样上一个的写入就实效。
			所以要加锁🔓，同时只能一个线程访问文件。
			
		    	Linux提供一把互斥锁mutex(也称之为互斥量)
			每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束后解锁。
			资源还是共享的，线程间也还是竞争的，但通过锁将资源的访问变为互斥操作，而后与时间有关的错误也不会在产生了。
		
			pthread_mutex_t:	互斥量，其实是限制了某一段代码的运行，而不是变量。在临界区前加锁，之后解锁，这样其他需要加锁的代码就无法再此期间
					运行。是一个结构体，最后要记得销毁，因为是全局变量。
		
			pthread_mutex_init():
			
			pthread_mutex_destroy():
	
			pthread_mutex_lock():
			
			pthread_mutex_trylock():

			pthread_mutex_unlock():
			
		线程池详见primerpool.c
		
		条件变量：	通常和互斥锁一起使用，当不满足条件时等待，不参与竞争，当条件满足时通知此线程去竞争资源。
			在生产者消费者模型中，极大提高了效率，当没有物资时，消费者停止竞争，只让生产者生产。（最大优点就是减少竞争）
			在满足某个线程运行条件时，再去竞争。
			
			pthread_cond_t:		条件结构体，最后记得销毁。
			
			pthread_cond_init()函数               功能：初始化一个条件变量

			pthread_cond_wait()函数             功能：阻塞等待一个条件变量

			pthread_cond_timedwait()函数    功能：限时等待一个条件变量

			pthread_cond_signal()函数          功能：唤醒至少一个阻塞在条件变量上的线程

			pthread_cond_broadcast()函数    功能：唤醒全部阻塞在条件变量上的线程

			pthread_cond_destroy()函数        功能：销毁一个条件变量
			
			
		信号量:		用条件变量和互斥量共同实现（和primerpool一样，只是生产者不只可以生产一个，而是多个，然后消费者从里面可以一直拿，直至信号量<=0）。
			可以用至令牌筒模型（一个线程生产token，其他几个消耗token打印东西）。
			
		读写锁：	r锁：有限个线程去只读资源；	w锁：只允许一个线程去写（第二个也不能读）
		
				r锁相当于信号量（互斥量和条件变量）(这里互斥量是在做条件变量加减时上锁，而读资源这个动作本身是不需要锁的)；加读锁：将锁变量加1,如果最高位为1,说明有写锁，无法加锁直至写锁释放。
				w锁相当于互斥量。将锁变量最高位置为1.
				
				设置写优先，则是加一个写优先标志位，当 有写请求时，变为1 ，这样其他读锁会知道有写锁想写，会等待，直到写锁成功加锁，处理数据，并解锁，同时将写优先位换为0.
				
				
				pthread_rwlock_t:	读写锁；
				pthread_rwlockattr_init(&attr);		初始化读写锁属性
				
				pthread_rwlockattr_setkind_np(&attr,PTHREAD_RWLOCK_PREFER_WRITER_NP);	设置为写锁优先
				
				pthread_rwlock_init(&rwlock,&attr);	用设置好的属性初始化读写锁
				
				pthread_rwlock_unlock();	无需知道此线程加的什么锁，只要看锁的状态，如果读锁大于0,则读锁-1即可，如果写锁>0,则写锁-1.
				
				
		
				
		
		
	4.线程属性：
		线程同步的属性：***
			
		
	5.重入:
		所有io都支持多线程（比如puts();，在往stdout中输出前，锁住stdout，然后输出，解锁）。
		所有io还有一个版本 puts_unlock，如果是单进程单线程程序，可以用这个，效率稍微高一点.
		
		如果函数使用了静态变量，则可能是不可重入且线程不安全的。
		
	6.线程和信号，fork的关系
	
	信号：
		 其实信号的mask位图只在线程中，然后进程有一个pending，线程还有一个单独的pending；之前进程中的处理信号，是用线程中的mask与进程的pending按位与；
		 多线程则是分别用mask和进程以及本线程的pending按位与。
		 
		 pthread_sigmask();
		 sigwait();
		 pthread_kill();
	 
	 fork：
		posix中只复制当前的线程，而不是所有线程。
		 
		 
		 
		 
		 
	
		
	
	

